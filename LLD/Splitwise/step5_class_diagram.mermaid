%% ========================================
%% STEP 5: ADD REPOSITORY LAYER
%% ========================================
%% WHAT WE ADDED: Repository interfaces for data access
%% WHY: Separate business logic from database operations
%% ========================================

classDiagram
    %% ========== SERVICES (from Step 4) ==========
    class UserService {
        <<Service>>
        -UserRepository userRepository
        +registerUser(UserDTO) User
        +getUserById(userId) User
    }

    class GroupService {
        <<Service>>
        -GroupRepository groupRepository
        +createGroup(...) Group
        +getGroupById(groupId) Group
    }

    class ExpenseService {
        <<Service>>
        -ExpenseRepository expenseRepository
        +addExpense(ExpenseDTO) Expense
        +getExpensesByGroup(groupId) List
    }

    class TransactionService {
        <<Service>>
        -TransactionRepository transactionRepository
        +recordPayment(...) Transaction
    }

    %% ========== REPOSITORY INTERFACES ==========

    class UserRepository {
        <<Interface>>
        +save(User) void
        +findById(userId) Optional~User~
        +findByEmail(email) Optional~User~
        +existsByEmail(email) boolean
        +update(User) void
        +delete(userId) void
        +findAll() List~User~
    }

    class GroupRepository {
        <<Interface>>
        +save(Group) void
        +findById(groupId) Optional~Group~
        +findByUserId(userId) List~Group~
        +update(Group) void
        +delete(groupId) void
        +addMemberToGroup(groupId, userId) void
        +removeMemberFromGroup(groupId, userId) void
        +getMembersByGroup(groupId) List~User~
        +isUserMember(groupId, userId) boolean
    }

    class ExpenseRepository {
        <<Interface>>
        +save(Expense) void
        +findById(expenseId) Optional~Expense~
        +findByGroupId(groupId) List~Expense~
        +findByUserId(userId) List~Expense~
        +findByParticipant(userId) List~Expense~
        +findByDateRange(start, end) List~Expense~
        +update(Expense) void
        +delete(expenseId) void
    }

    class TransactionRepository {
        <<Interface>>
        +save(Transaction) void
        +findById(transactionId) Optional~Transaction~
        +findByUserId(userId) List~Transaction~
        +findByGroupId(groupId) List~Transaction~
        +findByPayerId(payerId) List~Transaction~
        +findByPayeeId(payeeId) List~Transaction~
        +findByDateRange(start, end) List~Transaction~
        +update(Transaction) void
        +delete(transactionId) void
    }

    %% ========== JPA IMPLEMENTATIONS ==========

    class JpaUserRepository {
        <<Implementation>>
        +save(User) void
        +findById(userId) Optional~User~
        +findByEmail(email) Optional~User~
        +existsByEmail(email) boolean
        +update(User) void
        +delete(userId) void
        +findAll() List~User~
    }

    class JpaGroupRepository {
        <<Implementation>>
        +save(Group) void
        +findById(groupId) Optional~Group~
        +addMemberToGroup(...) void
        +getMembersByGroup(...) List~User~
    }

    class JpaExpenseRepository {
        <<Implementation>>
        +save(Expense) void
        +findById(expenseId) Optional~Expense~
        +findByGroupId(groupId) List~Expense~
    }

    class JpaTransactionRepository {
        <<Implementation>>
        +save(Transaction) void
        +findById(transactionId) Optional~Transaction~
    }

    %% ========== IN-MEMORY IMPLEMENTATIONS (for testing) ==========

    class InMemoryUserRepository {
        <<Implementation>>
        -Map~String, User~ users
        +save(User) void
        +findById(userId) Optional~User~
    }

    class InMemoryGroupRepository {
        <<Implementation>>
        -Map~String, Group~ groups
        -Map~String, Set~String~~ groupMembers
        +save(Group) void
        +addMemberToGroup(...) void
    }

    %% ========== DATABASE ==========
    class MySQLDatabase {
        <<Database>>
        Tables:
        - users
        - groups
        - user_groups (join table)
        - expenses
        - expense_participants (join table)
        - transactions
    }

    %% ========== RELATIONSHIPS ==========

    %% Services use Repository Interfaces
    UserService --> UserRepository : uses
    GroupService --> GroupRepository : uses
    ExpenseService --> ExpenseRepository : uses
    TransactionService --> TransactionRepository : uses

    %% Interfaces implemented by JPA classes
    UserRepository <|.. JpaUserRepository : implements
    GroupRepository <|.. JpaGroupRepository : implements
    ExpenseRepository <|.. JpaExpenseRepository : implements
    TransactionRepository <|.. JpaTransactionRepository : implements

    %% Interfaces implemented by In-Memory classes
    UserRepository <|.. InMemoryUserRepository : implements
    GroupRepository <|.. InMemoryGroupRepository : implements

    %% JPA implementations connect to database
    JpaUserRepository --> MySQLDatabase : queries
    JpaGroupRepository --> MySQLDatabase : queries
    JpaExpenseRepository --> MySQLDatabase : queries
    JpaTransactionRepository --> MySQLDatabase : queries

    %% ========== NOTES ==========

    note for UserRepository "ğŸ“š REPOSITORY PATTERN\nâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\nâœ… Interface defines contract\nâœ… Services depend on interface\nâœ… Not on implementation\nâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\nğŸ¯ Dependency Inversion Principle\nâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\nWHY?\nâ€¢ Easy to swap implementations\nâ€¢ Test with in-memory version\nâ€¢ Production uses JPA/MySQL"

    note for JpaUserRepository "ğŸ’¾ JPA IMPLEMENTATION\nâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\nUses Spring Data JPA:\n@Repository\ninterface UserRepo\n  extends JpaRepository<User, String>\nâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\nAuto-generates SQL:\nâ€¢ save() â†’ INSERT\nâ€¢ findById() â†’ SELECT WHERE\nâ€¢ delete() â†’ DELETE\nâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\nNo manual SQL needed!"

    note for InMemoryUserRepository "ğŸ§ª IN-MEMORY FOR TESTING\nâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\nUses HashMap:\nprivate Map<String, User> users\nâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\nBENEFITS:\nâœ… Fast (no database)\nâœ… Isolated tests\nâœ… No setup needed\nâœ… Same interface as JPA\nâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\nTests don't know the difference!"

    note for MySQLDatabase "ğŸ—„ï¸ DATABASE SCHEMA\nâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\nTABLES:\nâ€¢ users (id, name, email, ...)\nâ€¢ groups (id, name, created_by, ...)\nâ€¢ user_groups (user_id, group_id)\nâ€¢ expenses (id, amount, paid_by, ...)\nâ€¢ expense_participants (expense_id, user_id, amount)\nâ€¢ transactions (id, payer, payee, ...)\nâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\nINDEXES:\nâ€¢ idx_user_email (for login)\nâ€¢ idx_expense_group (for queries)\nâ€¢ idx_transaction_user"

    note for GroupRepository "ğŸ”— MANY-TO-MANY HANDLING\nâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\nGroup â†” User is Many-to-Many\nâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\nMethods:\nâ€¢ addMemberToGroup()\n  â†’ INSERT INTO user_groups\nâ€¢ removeMemberFromGroup()\n  â†’ DELETE FROM user_groups\nâ€¢ getMembersByGroup()\n  â†’ JOIN users & user_groups\nâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\nHides join table complexity!"

%% ========================================
%% KEY CONCEPTS:
%% 1. Repository Pattern - interface for data access
%% 2. Dependency Inversion - services depend on interface
%% 3. Multiple implementations - JPA for prod, In-Memory for test
%% 4. Separation of Concerns - data access separate from logic
%% ========================================
